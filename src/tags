!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADD_STR	lex.c	2070;"	d	file:
ANIS_ERR	vario.c	1028;"	d	file:
BEGIN	lex.c	144;"	d	file:
BINARY_NATIVE	mapio.c	96;"	d	file:
BINARY_NON_NATIVE	mapio.c	97;"	d	file:
C	gls.c	/^	MAT *C,        \/* (Generalized) Covariance matrix *\/$/;"	m	struct:__anon1	file:
CHECK_BITX	data.c	316;"	d	file:
CHECK_BITY	data.c	317;"	d	file:
CHECK_BITZ	data.c	318;"	d	file:
CHECK_CELLSIZE	mapio.c	91;"	d	file:
CHECK_COLS	mapio.c	90;"	d	file:
CHECK_ROWS	mapio.c	89;"	d	file:
CHECK_SUM	mapio.c	94;"	d	file:
CHECK_X_UL	mapio.c	92;"	d	file:
CHECK_Y_UL	mapio.c	93;"	d	file:
CHfactor	chol.c	/^MAT *CHfactor(MAT *m, int *info) {$/;"	f
CHsolve	chol.c	/^VEC *CHsolve(MAT *m, VEC *b, VEC *out) {$/;"	f
CinvX	gls.c	/^		*CinvX,    \/* C-1 X *\/$/;"	m	struct:__anon1	file:
DEFAULT_MISVAL	mapio.c	98;"	d	file:
DEG2RAD	vario.c	1030;"	d	file:
DPSWAP	select.c	59;"	d	file:
ECHO	lex.c	711;"	d	file:
EOB_ACT_CONTINUE_SCAN	lex.c	187;"	d	file:
EOB_ACT_END_OF_FILE	lex.c	188;"	d	file:
EOB_ACT_LAST_MATCH	lex.c	189;"	d	file:
EVFMT	sem.c	817;"	d	file:
EXIT_SUCCESS	parse.c	430;"	d	file:
EXIT_SUCCESS	parse.c	458;"	d	file:
FILL_TABLE	parse.c	2600;"	d	file:
FIT_LOG	fit.c	53;"	d	file:
FLEXINT_H	lex.c	48;"	d	file:
FLEX_BETA	lex.c	32;"	d	file:
FLEX_SCANNER	lex.c	27;"	d	file:
FLT_MAX	read.c	59;"	d	file:
FLT_MIN	read.c	60;"	d	file:
Float	msim.c	/^typedef double Float; \/* doubles the memory requirement -> may be pretty much *\/$/;"	t	file:
Float	msim.c	/^typedef float Float;$/;"	t	file:
GEZERO	parse.c	/^		GEZERO, $/;"	e	enum:__anon2::__anon4	file:
GLM	gls.c	/^} GLM; \/* structure is locally defined, will be held in void *glm in DATA *\/$/;"	t	typeref:struct:__anon1	file:
GSTAT_EXPR	parse.c	/^} GSTAT_EXPR;$/;"	t	typeref:struct:__anon2	file:
GTZERO	parse.c	/^		GTZERO $/;"	e	enum:__anon2::__anon4	file:
HUGE_VAL	read.c	63;"	d	file:
IDENT	parse.c	/^    IDENT = 262,$/;"	e	enum:yytokentype	file:
IDENT	parse.c	253;"	d	file:
ID_AREA	parse.c	/^    ID_AREA = 274,$/;"	e	enum:yytokentype	file:
ID_AREA	parse.c	265;"	d	file:
ID_BLOCK	parse.c	/^    ID_BLOCK = 275,$/;"	e	enum:yytokentype	file:
ID_BLOCK	parse.c	266;"	d	file:
ID_BOUNDS	parse.c	/^    ID_BOUNDS = 277,$/;"	e	enum:yytokentype	file:
ID_BOUNDS	parse.c	268;"	d	file:
ID_COVARIANCES	parse.c	/^    ID_COVARIANCES = 268,$/;"	e	enum:yytokentype	file:
ID_COVARIANCES	parse.c	259;"	d	file:
ID_DATA	parse.c	/^    ID_DATA = 263,$/;"	e	enum:yytokentype	file:
ID_DATA	parse.c	254;"	d	file:
ID_EDGES	parse.c	/^    ID_EDGES = 271,$/;"	e	enum:yytokentype	file:
ID_EDGES	parse.c	262;"	d	file:
ID_MARGINALS	parse.c	/^    ID_MARGINALS = 278$/;"	e	enum:yytokentype	file:
ID_MARGINALS	parse.c	269;"	d	file:
ID_MASKS	parse.c	/^    ID_MASKS = 270,$/;"	e	enum:yytokentype	file:
ID_MASKS	parse.c	261;"	d	file:
ID_MERGE	parse.c	/^    ID_MERGE = 273,$/;"	e	enum:yytokentype	file:
ID_MERGE	parse.c	264;"	d	file:
ID_METHOD	parse.c	/^    ID_METHOD = 276,$/;"	e	enum:yytokentype	file:
ID_METHOD	parse.c	267;"	d	file:
ID_OUTPUT	parse.c	/^    ID_OUTPUT = 269,$/;"	e	enum:yytokentype	file:
ID_OUTPUT	parse.c	260;"	d	file:
ID_PREDICTIONS	parse.c	/^    ID_PREDICTIONS = 266,$/;"	e	enum:yytokentype	file:
ID_PREDICTIONS	parse.c	257;"	d	file:
ID_SET	parse.c	/^    ID_SET = 272,$/;"	e	enum:yytokentype	file:
ID_SET	parse.c	263;"	d	file:
ID_VARIANCES	parse.c	/^    ID_VARIANCES = 267,$/;"	e	enum:yytokentype	file:
ID_VARIANCES	parse.c	258;"	d	file:
ID_VARIOGRAM	parse.c	/^    ID_VARIOGRAM = 265,$/;"	e	enum:yytokentype	file:
ID_VARIOGRAM	parse.c	256;"	d	file:
ID_X	parse.c	/^    ID_X = 264,$/;"	e	enum:yytokentype	file:
ID_X	parse.c	255;"	d	file:
INITIAL	lex.c	615;"	d	file:
INT	parse.c	/^    INT = 258,$/;"	e	enum:yytokentype	file:
INT	parse.c	249;"	d	file:
INT16_MAX	lex.c	90;"	d	file:
INT16_MIN	lex.c	81;"	d	file:
INT32_MAX	lex.c	93;"	d	file:
INT32_MIN	lex.c	84;"	d	file:
INT8_MAX	lex.c	87;"	d	file:
INT8_MIN	lex.c	78;"	d	file:
INT_MAX	read.c	51;"	d	file:
INT_MIN	read.c	52;"	d	file:
IS_D_VECTOR	parse.c	/^		IS_D_VECTOR, $/;"	e	enum:__anon2::__anon3	file:
IS_INT	parse.c	/^		IS_INT, $/;"	e	enum:__anon2::__anon3	file:
IS_REAL	parse.c	/^		IS_REAL, $/;"	e	enum:__anon2::__anon3	file:
IS_STRING	parse.c	/^		IS_STRING, $/;"	e	enum:__anon2::__anon3	file:
IS_UINT	parse.c	/^		IS_UINT, $/;"	e	enum:__anon2::__anon3	file:
IminAw	reml.c	/^static MAT *IminAw = MNULL;$/;"	v	file:
LDLfactor	mtrx.c	/^MAT *LDLfactor(MAT *M, int *info) { \/* do Choleski, as the Lapack R\/C interface doesn't LDL' *\/$/;"	f
LDLsolve	mtrx.c	/^VEC *LDLsolve(MAT *M, VEC *b, VEC *x) { \/* same thing here *\/$/;"	f
LONG_MAX	read.c	55;"	d	file:
LONG_MIN	read.c	56;"	d	file:
MAXCHAR	lex.c	2071;"	d	file:
MAX_ANG	direct.c	152;"	d	file:
MAX_ANG	direct.c	45;"	d	file:
MIN_BESS	vario_fn.c	51;"	d	file:
MY_input	lex.c	/^int MY_input(void) {$/;"	f
MY_output	lex.c	/^int MY_output(int c) {$/;"	f
MY_unput	lex.c	/^int MY_unput(int c) {$/;"	f
M_DEBUG	gls.c	87;"	d	file:
My_yy_lineno	lex.c	/^static int yy_Lexpos = 0, yy_Posafternl = 1, My_yy_lineno = 1,$/;"	v	file:
NEARLY_ZERO	fit.c	54;"	d	file:
NOLIMIT	parse.c	/^		NOLIMIT, $/;"	e	enum:__anon2::__anon4	file:
NO_ARG	parse.c	/^		NO_ARG $/;"	e	enum:__anon2::__anon3	file:
N_NODES	nsearch.c	73;"	d	file:
PI	vario_fn.c	53;"	d	file:
POWDI	gcdist.c	8;"	d	file:
QRcondest	mtrx.c	/^double QRcondest(MAT *a) {$/;"	f
QRfactor	mtrx.c	/^void QRfactor(MAT *a, VEC *b) {$/;"	f
QRsolve	mtrx.c	/^void QRsolve(MAT *m, VEC *a, VEC *b, VEC *c) {$/;"	f
QSTR	parse.c	/^    QSTR = 261,$/;"	e	enum:yytokentype	file:
QSTR	parse.c	252;"	d	file:
RANDIN	s.c	45;"	d	file:
RANDOUT	s.c	46;"	d	file:
REAL	parse.c	/^    REAL = 260,$/;"	e	enum:yytokentype	file:
REAL	parse.c	251;"	d	file:
REJECT	lex.c	500;"	d	file:
R_NORMAL	s.c	44;"	d	file:
R_UNIFORM	s.c	43;"	d	file:
SCANNED	lex.c	604;"	d	file:
SCANNED	lex.c	607;"	d	file:
SEM_INCREMENT	sem.c	61;"	d	file:
SLOW	data.c	701;"	d	file:
SURFER_MISVAL	mapio.c	99;"	d	file:
SWAP_M_N	mapio.c	86;"	d	file:
SWAP_N	mapio.c	85;"	d	file:
S_EVALUATOR	s.c	47;"	d	file:
TABLE_SIZE	parse.c	2597;"	d	file:
UINT	parse.c	/^    UINT = 259,$/;"	e	enum:yytokentype	file:
UINT	parse.c	250;"	d	file:
UINT16_MAX	lex.c	99;"	d	file:
UINT32_MAX	lex.c	102;"	d	file:
UINT8_MAX	lex.c	96;"	d	file:
UNKNOWN	parse.c	/^		UNKNOWN, $/;"	e	enum:__anon2::__anon3	file:
UPDATE_BLP	gls.c	91;"	d	file:
UPDATE_BLUP	gls.c	92;"	d	file:
V_DEBUG	gls.c	89;"	d	file:
VarName	s.c	/^static const char VarName[] = "(R Data)";$/;"	v	file:
WPWARNING	msim.c	209;"	d	file:
X	gls.c	/^		*X,        \/* design matrix, y = X beta + e *\/$/;"	m	struct:__anon1	file:
XCinvX	gls.c	/^		*XCinvX;   \/* X' C-1 X *\/$/;"	m	struct:__anon1	file:
XVXt_mlt	reml.c	/^MAT *XVXt_mlt(MAT *X, MAT *V, MAT *out) {$/;"	f
XdXt_mlt	reml.c	/^MAT *XdXt_mlt(MAT *X, VEC *d, MAT *out) {$/;"	f
XtVX_mlt	reml.c	/^MAT *XtVX_mlt(MAT *X, MAT *V, MAT *out) {$/;"	f
XtdX_mlt	reml.c	/^MAT *XtdX_mlt(MAT *X, VEC *d, MAT *out) {$/;"	f
YYABORT	parse.c	879;"	d	file:
YYACCEPT	parse.c	878;"	d	file:
YYBACKUP	parse.c	885;"	d	file:
YYBISON	parse.c	44;"	d	file:
YYBISON_VERSION	parse.c	47;"	d	file:
YYCASE_	parse.c	1226;"	d	file:
YYCASE_	parse.c	1236;"	d	file:
YYCOPY	parse.c	522;"	d	file:
YYCOPY	parse.c	525;"	d	file:
YYCOPY_NEEDED	parse.c	497;"	d	file:
YYDEBUG	parse.c	214;"	d	file:
YYDPRINTF	parse.c	1031;"	d	file:
YYDPRINTF	parse.c	916;"	d	file:
YYEMPTY	parse.c	875;"	d	file:
YYEOF	parse.c	876;"	d	file:
YYERRCODE	parse.c	904;"	d	file:
YYERROR	parse.c	880;"	d	file:
YYERROR_VERBOSE	parse.c	202;"	d	file:
YYERROR_VERBOSE	parse.c	203;"	d	file:
YYERROR_VERBOSE	parse.c	205;"	d	file:
YYFINAL	parse.c	538;"	d	file:
YYFPRINTF	parse.c	913;"	d	file:
YYFREE	parse.c	468;"	d	file:
YYINITDEPTH	parse.c	1040;"	d	file:
YYLAST	parse.c	540;"	d	file:
YYMALLOC	parse.c	462;"	d	file:
YYMAXDEPTH	parse.c	1051;"	d	file:
YYMAXUTOK	parse.c	554;"	d	file:
YYNNTS	parse.c	545;"	d	file:
YYNRULES	parse.c	547;"	d	file:
YYNSTATES	parse.c	549;"	d	file:
YYNTOKENS	parse.c	543;"	d	file:
YYPACT_NINF	parse.c	646;"	d	file:
YYPOPSTACK	parse.c	1351;"	d	file:
YYPULL	parse.c	59;"	d	file:
YYPURE	parse.c	53;"	d	file:
YYPUSH	parse.c	56;"	d	file:
YYRECOVERING	parse.c	883;"	d	file:
YYSIZE_MAXIMUM	parse.c	341;"	d	file:
YYSIZE_T	parse.c	330;"	d	file:
YYSIZE_T	parse.c	332;"	d	file:
YYSIZE_T	parse.c	335;"	d	file:
YYSIZE_T	parse.c	337;"	d	file:
YYSKELETON_NAME	parse.c	50;"	d	file:
YYSTACK_ALLOC	parse.c	416;"	d	file:
YYSTACK_ALLOC	parse.c	420;"	d	file:
YYSTACK_ALLOC	parse.c	425;"	d	file:
YYSTACK_ALLOC	parse.c	448;"	d	file:
YYSTACK_ALLOC_MAXIMUM	parse.c	445;"	d	file:
YYSTACK_ALLOC_MAXIMUM	parse.c	451;"	d	file:
YYSTACK_BYTES	parse.c	493;"	d	file:
YYSTACK_FREE	parse.c	439;"	d	file:
YYSTACK_FREE	parse.c	449;"	d	file:
YYSTACK_GAP_MAXIMUM	parse.c	489;"	d	file:
YYSTACK_RELOCATE	parse.c	504;"	d	file:
YYSTATE	lex.c	151;"	d	file:
YYSTYPE	parse.c	/^typedef union YYSTYPE YYSTYPE;$/;"	t	typeref:union:YYSTYPE	file:
YYSTYPE	parse.c	/^union YYSTYPE$/;"	u	file:
YYSTYPE_IS_DECLARED	parse.c	286;"	d	file:
YYSTYPE_IS_TRIVIAL	parse.c	285;"	d	file:
YYTABLES_NAME	lex.c	2007;"	d	file:
YYTABLE_NINF	parse.c	651;"	d	file:
YYTERROR	parse.c	903;"	d	file:
YYTOKENTYPE	parse.c	222;"	d	file:
YYTRANSLATE	parse.c	556;"	d	file:
YYUNDEFTOK	parse.c	553;"	d	file:
YYUSE	parse.c	384;"	d	file:
YYUSE	parse.c	386;"	d	file:
YY_	parse.c	347;"	d	file:
YY_	parse.c	351;"	d	file:
YY_ATTRIBUTE	parse.c	359;"	d	file:
YY_ATTRIBUTE	parse.c	361;"	d	file:
YY_ATTRIBUTE_PURE	parse.c	366;"	d	file:
YY_ATTRIBUTE_UNUSED	parse.c	370;"	d	file:
YY_AT_BOL	lex.c	360;"	d	file:
YY_BREAK	lex.c	790;"	d	file:
YY_BUFFER_EOF_PENDING	lex.c	276;"	d	file:
YY_BUFFER_NEW	lex.c	264;"	d	file:
YY_BUFFER_NORMAL	lex.c	265;"	d	file:
YY_BUFFER_STATE	lex.c	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	typeref:struct:yy_buffer_state	file:
YY_BUF_SIZE	lex.c	168;"	d	file:
YY_BUF_SIZE	lex.c	170;"	d	file:
YY_CHAR	lex.c	/^typedef unsigned char YY_CHAR;$/;"	t	file:
YY_CURRENT_BUFFER	lex.c	292;"	d	file:
YY_CURRENT_BUFFER_LVALUE	lex.c	299;"	d	file:
YY_DECL	lex.c	778;"	d	file:
YY_DECL_IS_OURS	lex.c	774;"	d	file:
YY_DO_BEFORE_ACTION	lex.c	385;"	d	file:
YY_END_OF_BUFFER	lex.c	393;"	d	file:
YY_END_OF_BUFFER_CHAR	lex.c	159;"	d	file:
YY_EXIT_FAILURE	lex.c	1802;"	d	file:
YY_EXTRA_TYPE	lex.c	626;"	d	file:
YY_FATAL_ERROR	lex.c	765;"	d	file:
YY_FLEX_MAJOR_VERSION	lex.c	28;"	d	file:
YY_FLEX_MINOR_VERSION	lex.c	29;"	d	file:
YY_FLEX_SUBMINOR_VERSION	lex.c	30;"	d	file:
YY_FLUSH_BUFFER	lex.c	328;"	d	file:
YY_GSTAT_YY_Y_TAB_H_INCLUDED	parse.c	211;"	d	file:
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	parse.c	391;"	d	file:
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	parse.c	401;"	d	file:
YY_IGNORE_MAYBE_UNINITIALIZED_END	parse.c	395;"	d	file:
YY_IGNORE_MAYBE_UNINITIALIZED_END	parse.c	402;"	d	file:
YY_INITIAL_VALUE	parse.c	398;"	d	file:
YY_INITIAL_VALUE	parse.c	405;"	d	file:
YY_INPUT	lex.c	582;"	d	file:
YY_INPUT	lex.c	583;"	d	file:
YY_INPUT	lex.c	718;"	d	file:
YY_INT_ALIGNED	lex.c	4;"	d	file:
YY_LESS_LINENO	lex.c	191;"	d	file:
YY_LOCATION_PRINT	parse.c	924;"	d	file:
YY_MORE_ADJ	lex.c	502;"	d	file:
YY_NEW_FILE	lex.c	157;"	d	file:
YY_NULL	lex.c	131;"	d	file:
YY_NULLPTR	parse.c	194;"	d	file:
YY_NULLPTR	parse.c	196;"	d	file:
YY_NUM_RULES	lex.c	392;"	d	file:
YY_READ_BUF_SIZE	lex.c	700;"	d	file:
YY_READ_BUF_SIZE	lex.c	702;"	d	file:
YY_REDUCE_PRINT	parse.c	1021;"	d	file:
YY_REDUCE_PRINT	parse.c	1034;"	d	file:
YY_RESTORE_YY_MORE_OFFSET	lex.c	503;"	d	file:
YY_RULE_SETUP	lex.c	793;"	d	file:
YY_SC_TO_UI	lex.c	138;"	d	file:
YY_STACK_PRINT	parse.c	1033;"	d	file:
YY_STACK_PRINT	parse.c	990;"	d	file:
YY_START	lex.c	150;"	d	file:
YY_START_STACK_INCR	lex.c	760;"	d	file:
YY_STATE_BUF_SIZE	lex.c	176;"	d	file:
YY_STATE_EOF	lex.c	154;"	d	file:
YY_STRUCT_YY_BUFFER_STATE	lex.c	217;"	d	file:
YY_SYMBOL_PRINT	parse.c	1032;"	d	file:
YY_SYMBOL_PRINT	parse.c	928;"	d	file:
YY_TYPEDEF_YY_BUFFER_STATE	lex.c	179;"	d	file:
YY_TYPEDEF_YY_SIZE_T	lex.c	212;"	d	file:
YY_USER_ACTION	lex.c	785;"	d	file:
YY_USE_CONST	lex.c	112;"	d	file:
YY_USE_CONST	lex.c	119;"	d	file:
_Noreturn	parse.c	376;"	d	file:
_Noreturn	parse.c	378;"	d	file:
__STDC_LIMIT_MACROS	lex.c	58;"	d	file:
__STDC__	parse.c	152;"	d	file:
__ip__	mtrx.c	/^double __ip__(double *p1, double *p2, int n) { \/* inner product of p1 and p2 *\/$/;"	f
all_directions	direct.c	/^static int all_directions = -1;$/;"	v	file:
alloc_exp_variogram	sem.c	/^static SAMPLE_VGM *alloc_exp_variogram(DATA *a, DATA *b, SAMPLE_VGM *ev) {$/;"	f	file:
alloca	parse.c	423;"	d	file:
allow_vector_only	parse.c	/^	vector_only = 0, allow_vector_only = 0;$/;"	v	file:
almost_equals	utils.c	/^int almost_equals(const char *tok, const char *str) {$/;"	f
alpha	direct.c	/^static double alpha = 0.0, beta = 0.0,$/;"	v	file:
anis	parse.c	/^static double range[NRANGEPARS], anis[5];$/;"	v	file:
argv0	glvars.c	/^char *argv0;$/;"	v
bbox_from_data	nsearch.c	/^static BBOX bbox_from_data(DATA *d) {$/;"	f	file:
bbox_from_grid	nsearch.c	/^static BBOX bbox_from_grid(const GRIDMAP *gt, const DATA_GRIDMAP *dg) {$/;"	f	file:
bessi1	vario_fn.c	/^static double bessi1(double x)$/;"	f	file:
bessk1	vario_fn.c	/^static double bessk1(double x)$/;"	f	file:
beta	direct.c	/^static double alpha = 0.0, beta = 0.0,$/;"	v	file:
beta	gls.c	/^		*beta;     \/* parameter vector *\/$/;"	m	struct:__anon1	file:
beta	msim.c	/^	***beta = NULL;$/;"	v	file:
block	glvars.c	/^static DPOINT block;$/;"	v	file:
block_discr	block.c	/^DATA *block_discr(DATA *d, const DPOINT *block, const DPOINT *where) {$/;"	f
boundary_file	parse.c	/^static char **ofn = NULL, *boundary_file = NULL;$/;"	v	file:
bp	parse.c	/^static DPOINT *bp = NULL;$/;"	v	file:
calc_VinvIminAw	reml.c	/^static MAT *calc_VinvIminAw(MAT *Vw, MAT *X, MAT *VinvIminAw, int calc_Aw) {$/;"	f	file:
calc_data_mean_std	data.c	/^static void calc_data_mean_std(DATA *d) {$/;"	f	file:
calc_ll	reml.c	/^static double calc_ll(MAT *Vw, MAT *X, VEC *y, int n) {$/;"	f	file:
calc_lm	lm.c	/^LM *calc_lm(LM *lm) {$/;"	f
calc_mu	lm.c	/^double calc_mu(const DATA *d, const DPOINT *where) {$/;"	f
calc_polynomial	data.c	/^double calc_polynomial(DPOINT *p, int colX) {$/;"	f
calc_polynomial_point	data.c	/^void calc_polynomial_point(DATA *d, DPOINT *pt) {$/;"	f
calc_polynomials	data.c	/^void calc_polynomials(DATA *d) {$/;"	f
calc_r	stat.c	/^void calc_r(double *a, double *b, int n, double *corr) {$/;"	f
calc_rhs_Tr_m	reml.c	/^static void calc_rhs_Tr_m(int n_models, MAT **Vk,MAT *VinvIminAw, $/;"	f	file:
calc_variogram	sem.c	/^int calc_variogram(VARIOGRAM *v \/* pointer to VARIOGRAM structure *\/,$/;"	f
centre_area	data.c	/^void centre_area(DATA *area) {$/;"	f
check_assign_expr	parse.c	/^static void check_assign_expr(GSTAT_EXPR *expr) {$/;"	f	file:
check_global_variables	glvars.c	/^void check_global_variables(void) {$/;"	f
check_variography	vario.c	/^void check_variography(const VARIOGRAM **v, int n_vars)$/;"	f
clean_up	glvars.c	/^static void clean_up(void) {$/;"	f	file:
col1	parse.c	/^static int id = -1, id1 = -1, id2 = -1, col1 = -1, col2 = -1,$/;"	v	file:
col2	parse.c	/^static int id = -1, id1 = -1, id2 = -1, col1 = -1, col2 = -1,$/;"	v	file:
command_file_name	glvars.c	/^char *command_file_name;$/;"	v
command_line	glvars.c	/^char *command_line;$/;"	v
cond_sim	sim.c	/^const double *cond_sim(double *est, int dim, METHOD m, int *is_datum, int orc) {$/;"	f
convert_C	gls.c	/^static void convert_C(MAT *C, VEC *mu, double (*fn)(double)) {$/;"	f	file:
convert_C0	gls.c	/^static void convert_C0(MAT *C0, VEC *mu, VEC *mu0, double (*fn)(double)) {$/;"	f	file:
convert_MSPE	gls.c	/^static void convert_MSPE(MAT *MSPE, VEC *mu0, double (*fn)(double)) {$/;"	f	file:
coordinates_are_equal	data.c	/^int coordinates_are_equal(const DATA *a, const DATA *b) {$/;"	f
correct_orv	sim.c	/^void correct_orv(double *est, int n_vars, int orc) {$/;"	f
cos_tol_hor	direct.c	/^	cos_tol_hor = -1.0, cos_tol_ver = -1.0, \/* Changed K.M. Fri Feb 27 11:13:47 1998 *\/$/;"	v	file:
cos_tol_ver	direct.c	/^	cos_tol_hor = -1.0, cos_tol_ver = -1.0, \/* Changed K.M. Fri Feb 27 11:13:47 1998 *\/$/;"	v	file:
covariogram	sem.c	/^static SAMPLE_VGM *covariogram(DATA *d, SAMPLE_VGM *ev) {$/;"	f	file:
cp	lex.c	/^static char *cp = NULL;$/;"	v	file:
create_data_area	glvars.c	/^DATA *create_data_area(void) {$/;"	f
create_lm	lm.c	/^static void create_lm(DATA **data, int nvars) {$/;"	f	file:
cross_covariogram	sem.c	/^static SAMPLE_VGM *cross_covariogram(DATA *a, DATA *b, SAMPLE_VGM *ev) {$/;"	f	file:
cross_variogram	sem.c	/^static SAMPLE_VGM *cross_variogram(DATA *a, DATA *b, SAMPLE_VGM *ev) {$/;"	f	file:
d	parse.c	/^static DATA *d = NULL, **dpp = NULL;$/;"	v	file:
d2s	msim.c	/^	**d2s = NULL;$/;"	v	file:
d_cmp	stat.c	/^int CDECL d_cmp(const double *a, const double *b) {$/;"	f
da_fn_exponential	vario_fn.c	/^double da_fn_exponential(double h, double *r) {$/;"	f
da_fn_gaussian	vario_fn.c	/^double da_fn_gaussian(double h, double *r) {$/;"	f
da_fn_hole	vario_fn.c	/^double da_fn_hole(double h, double *r) {$/;"	f
da_fn_linear	vario_fn.c	/^double da_fn_linear(double h, double *r) {$/;"	f
da_fn_logarithmic	vario_fn.c	/^double da_fn_logarithmic(double h, double *r) {$/;"	f
da_fn_pentaspherical	vario_fn.c	/^double da_fn_pentaspherical(double h, double *r) {$/;"	f
da_fn_periodic	vario_fn.c	/^double da_fn_periodic(double h, double *r) {$/;"	f
da_fn_power	vario_fn.c	/^double da_fn_power(double h, double *r) {$/;"	f
da_fn_spherical	vario_fn.c	/^double da_fn_spherical(double h, double *r) {$/;"	f
da_fn_wave	vario_fn.c	/^double da_fn_wave(double h, double *r) {$/;"	f
da_general	vario.c	/^double da_general(VGM_MODEL *part, double h) {$/;"	f
da_is_zero	vario_fn.c	/^double da_is_zero(double h, double *r) {$/;"	f
data	glvars.c	/^static DATA **data = NULL;$/;"	v	file:
data_add_X	data.c	/^void data_add_X(DATA *d, int col) {$/;"	f
data_area	glvars.c	/^static DATA *data_area = NULL; \/* area that discretises block *\/$/;"	v	file:
data_block_diagonal	data.c	/^double data_block_diagonal(DATA *data) {$/;"	f
data_types	data.c	/^const DATA_TYPE data_types[] = {$/;"	v
datagrid_rebuild	data.c	/^void datagrid_rebuild(DATA *d, int adjust_to_gridcentres) {$/;"	f
debug_level	glvars.c	/^int debug_level; \/* debug level *\/$/;"	v
debug_result	gls.c	/^static void debug_result(VEC *blup, MAT *MSPE, enum GLS_WHAT pred) {$/;"	f	file:
decide_on_coincide	glvars.c	/^int decide_on_coincide(void) {$/;"	f
dequeue	pqueue.c	/^Q_ELEMENT_WHAT dequeue(QUEUE *q) {$/;"	f
dir_h	direct.c	/^	dir_v[2] = { 1.0, 0.0 } , dir_h[2] = { 0.0, 1.0 };$/;"	v	file:
dir_v	direct.c	/^	dir_v[2] = { 1.0, 0.0 } , dir_h[2] = { 0.0, 1.0 };$/;"	v	file:
dist_cmp	select.c	/^int CDECL dist_cmp(const DPOINT **pa, const DPOINT **pb) {$/;"	f
divide	sem.c	/^static void divide(SAMPLE_VGM *ev) {$/;"	f	file:
do_print_progress	s.c	/^int do_print_progress = 0;$/;"	v
dpp	parse.c	/^static DATA *d = NULL, **dpp = NULL;$/;"	v	file:
dval	parse.c	/^	double dval;$/;"	m	union:YYSTYPE	file:
ecalloc	utils.c	/^void *ecalloc(size_t nobj, size_t size) {$/;"	f
effective_range	vario.c	/^double effective_range(const VARIOGRAM *v) {$/;"	f
efree	pqueue.c	57;"	d	file:
efree	utils.c	/^void efree(void *p) {$/;"	f
emalloc	pqueue.c	55;"	d	file:
emalloc	utils.c	/^void *emalloc(size_t size) {$/;"	f
enlarge_queue	pqueue.c	/^static void enlarge_queue(QUEUE *q) {$/;"	f	file:
enqueue	pqueue.c	/^void enqueue(QUEUE *q, Q_ELEMENT_WHAT *el, int n) {$/;"	f
erealloc	pqueue.c	56;"	d	file:
erealloc	utils.c	/^void *erealloc(void *p, size_t size) {$/;"	f
error_messages	userio.c	/^static const char *error_messages[MAX_ERRNO+1] = {$/;"	v	file:
est_quant	stat.c	/^double est_quant(double *list, double p, int n) {$/;"	f
est_quantile_div	getest.c	/^static void est_quantile_div(DATA *data, double *est, int div) {$/;"	f	file:
est_skew_kurt	getest.c	/^static void est_skew_kurt(DATA *data, double *est) {$/;"	f	file:
expr	parse.c	/^GSTAT_EXPR expr = { NULL, NULL, UNKNOWN, NOLIMIT };$/;"	v
fill_cutoff_width	sem.c	/^void fill_cutoff_width(DATA *data \/* pointer to DATA structure to derive$/;"	f
fill_est	gls.c	/^static void fill_est(DATA **d, VEC *blup, MAT *MSPE, int n_vars, double *est)$/;"	f	file:
fill_weights	fit.c	/^static int fill_weights(const VARIOGRAM *vp, PERM *p, LM *lm) {$/;"	f	file:
fit_GaussNewton	fit.c	/^static int fit_GaussNewton(VARIOGRAM *vp, PERM *p, LM *lm, int iter,$/;"	f	file:
fit_int2enum	vario.c	/^FIT_TYPE fit_int2enum(int fit) {$/;"	f
fit_range	parse.c	/^	fit_sill = 0, fit_range = 0, nrangepars = 1,$/;"	v	file:
fit_shift	vario.c	/^FIT_TYPE fit_shift(FIT_TYPE now, int next) {$/;"	f
fit_sill	parse.c	/^	fit_sill = 0, fit_range = 0, nrangepars = 1,$/;"	v	file:
fit_variogram	fit.c	/^int fit_variogram(VARIOGRAM *v) {$/;"	f
fix_minmax	data.c	/^static int fix_minmax = 0;$/;"	v	file:
flex_int16_t	lex.c	/^typedef int16_t flex_int16_t;$/;"	t	file:
flex_int16_t	lex.c	/^typedef short int flex_int16_t;$/;"	t	file:
flex_int32_t	lex.c	/^typedef int flex_int32_t;$/;"	t	file:
flex_int32_t	lex.c	/^typedef int32_t flex_int32_t;$/;"	t	file:
flex_int8_t	lex.c	/^typedef int8_t flex_int8_t;$/;"	t	file:
flex_int8_t	lex.c	/^typedef signed char flex_int8_t;$/;"	t	file:
flex_uint16_t	lex.c	/^typedef uint16_t flex_uint16_t;$/;"	t	file:
flex_uint16_t	lex.c	/^typedef unsigned short int flex_uint16_t;$/;"	t	file:
flex_uint32_t	lex.c	/^typedef uint32_t flex_uint32_t;$/;"	t	file:
flex_uint32_t	lex.c	/^typedef unsigned int flex_uint32_t;$/;"	t	file:
flex_uint8_t	lex.c	/^typedef uint8_t flex_uint8_t;$/;"	t	file:
flex_uint8_t	lex.c	/^typedef unsigned char flex_uint8_t; $/;"	t	file:
fn_bessel	vario_fn.c	/^double fn_bessel(double h, double *r) {$/;"	f
fn_circular	vario_fn.c	/^double fn_circular(double h, double *r) {$/;"	f
fn_exclass	vario_fn.c	/^double fn_exclass(double h, double *r) {$/;"	f
fn_exponential	vario_fn.c	/^double fn_exponential(double h, double *r) {$/;"	f
fn_gaussian	vario_fn.c	/^double fn_gaussian(double h, double *r) {$/;"	f
fn_hole	vario_fn.c	/^double fn_hole(double h, double *r) {$/;"	f
fn_intercept	vario_fn.c	/^double fn_intercept(double h, double *r) {$/;"	f
fn_legendre	vario_fn.c	/^double fn_legendre(double h, double *r) {$/;"	f
fn_linear	vario_fn.c	/^double fn_linear(double h, double *r) {$/;"	f
fn_logarithmic	vario_fn.c	/^double fn_logarithmic(double h, double *r) {$/;"	f
fn_matern	vario_fn.c	/^double fn_matern(double h, double *p) {$/;"	f
fn_matern2	vario_fn.c	/^double fn_matern2(double h, double *p) {$/;"	f
fn_nugget	vario_fn.c	/^double fn_nugget(double h, double *r) {$/;"	f
fn_pentaspherical	vario_fn.c	/^double fn_pentaspherical(double h, double *r) {$/;"	f
fn_periodic	vario_fn.c	/^double fn_periodic(double h, double *r) {$/;"	f
fn_power	vario_fn.c	/^double fn_power(double h, double *r) {$/;"	f
fn_spherical	vario_fn.c	/^double fn_spherical(double h, double *r) {$/;"	f
fn_spline	vario_fn.c	/^double fn_spline(double h, double *r) {$/;"	f
fn_wave	vario_fn.c	/^double fn_wave(double h, double *r) {$/;"	f
format	lm.c	/^static char    *format = "%14.9g ";$/;"	v	file:
fprint_sample_vgm	sem.c	/^void fprint_sample_vgm(const SAMPLE_VGM *ev) {$/;"	f
free_d_vector	data.c	/^void free_d_vector(D_VECTOR *v) {$/;"	f
free_data	data.c	/^void free_data(DATA *d) {$/;"	f
free_data_gridmap	data.c	/^static void free_data_gridmap(DATA_GRIDMAP *t) {$/;"	f	file:
free_glm	gls.c	/^void free_glm(void *v_glm) {$/;"	f
free_lm	lm.c	/^void free_lm(LM *lm) {$/;"	f
free_queue	pqueue.c	/^void free_queue(QUEUE *q) {$/;"	f
free_simulations	msim.c	/^void free_simulations(void) {$/;"	f
free_variogram	vario.c	/^void free_variogram(VARIOGRAM *v) {$/;"	f
gauss	block.c	/^static double gauss[4] = { $/;"	v	file:
gauss_w	block.c	/^double gauss_w[4] = {$/;"	v
getSSErr	fit.c	/^static double getSSErr(const VARIOGRAM *vp, PERM *p, LM *lm) {$/;"	f	file:
get_X	lm.c	/^MAT *get_X(DATA **d, MAT *X, int nvars) {$/;"	f
get_X0	lm.c	/^MAT *get_X0(DATA **d, MAT *X0, DPOINT *where, int nvars) {$/;"	f
get_area_centre	data.c	/^DATA *get_area_centre(DATA *area, DATA *d) {$/;"	f
get_block_p	glvars.c	/^DPOINT *get_block_p(void) {$/;"	f
get_col	mtrx.c	/^VEC *get_col(MAT *M, size_t i, VEC *to) {$/;"	f
get_colX_nr	lm.c	/^static int get_colX_nr(DATA **d, int var, int this_x) {$/;"	f	file:
get_corr_mat	gls.c	/^static MAT *get_corr_mat(MAT *C, MAT *R) {$/;"	f	file:
get_covariance	vario.c	/^double get_covariance(const VARIOGRAM *vp, double dx, double dy, double dz) {$/;"	f
get_covariance_list	s.c	/^SEXP get_covariance_list(SEXP ids, SEXP covariance, SEXP dist_list) {$/;"	f
get_data_area	glvars.c	/^DATA *get_data_area(void) {$/;"	f
get_dataval	glvars.c	/^DATA *get_dataval(void) {$/;"	f
get_default_method	glvars.c	/^METHOD get_default_method(void) {$/;"	f
get_est	getest.c	/^void get_est(DATA **data, METHOD method, DPOINT *where, double *est) {$/;"	f
get_free	pqueue.c	/^static Q_ELEMENT *get_free(QUEUE *q) {$/;"	f	file:
get_gstat_data	glvars.c	/^DATA **get_gstat_data(void) {$/;"	f
get_index	nsearch.c	90;"	d	file:
get_index	sem.c	/^static int get_index(double dist, SAMPLE_VGM *ev) {$/;"	f	file:
get_max_sill	vario.c	/^double get_max_sill(int n) {$/;"	f
get_method	glvars.c	/^METHOD get_method(void) {$/;"	f
get_mode	glvars.c	/^MODE get_mode(void) {$/;"	f
get_msim	msim.c	/^float ***get_msim(void) {$/;"	f
get_mu	gls.c	/^static VEC *get_mu(VEC *mu, const VEC *y, DATA **d, int n_vars) {$/;"	f	file:
get_n_beta_set	glvars.c	/^int get_n_beta_set(void) {$/;"	f
get_n_outfile	glvars.c	/^int get_n_outfile(void) {$/;"	f
get_n_sim_locs_table	msim.c	/^static unsigned int *get_n_sim_locs_table(unsigned int *size) {$/;"	f	file:
get_n_variogram_models	vario.c	/^int get_n_variogram_models(void) {$/;"	f
get_n_vars	glvars.c	/^int get_n_vars(void) {$/;"	f
get_n_vgms	glvars.c	/^int get_n_vgms(void) {$/;"	f
get_nearest_point	nsearch.c	/^static DPOINT *get_nearest_point(QUEUE *q, DPOINT *where, DATA *d) {$/;"	f	file:
get_outfile_name	glvars.c	/^const char **get_outfile_name(void) {$/;"	f
get_outfile_namei	glvars.c	/^const char *get_outfile_namei(int i) {$/;"	f
get_row	mtrx.c	/^VEC *get_row(MAT *m, size_t i, VEC *out) { \/* out <- i-th row of m *\/$/;"	f
get_semivariance	vario.c	/^double get_semivariance(const VARIOGRAM *vp, double dx, double dy, double dz) {$/;"	f
get_tm	vario.c	/^static ANIS_TM *get_tm(double anis[5]) {$/;"	f	file:
get_vgm	glvars.c	/^VARIOGRAM *get_vgm(int i) {$/;"	f
get_weights	lm.c	/^static VEC *get_weights(DATA **d, VEC *weights, int nvars) {$/;"	f	file:
get_y	lm.c	/^VEC *get_y(DATA **d, VEC *y, int nvars) {$/;"	f
gl_alpha	glvars.c	/^double gl_alpha; \/* alpha, beta, tol_[hor|ver]: anisotropy parameters *\/$/;"	v
gl_beta	glvars.c	/^double gl_beta;$/;"	v
gl_bounds	glvars.c	/^double *gl_bounds; \/* boundaries semivariogram intervals *\/$/;"	v
gl_coincide	glvars.c	/^int gl_coincide; \/* do the variable locations coincide? *\/$/;"	v
gl_cressie	glvars.c	/^int gl_cressie; \/* use cressie's estimator ? *\/$/;"	v
gl_cutoff	glvars.c	/^double gl_cutoff; \/* variogram cutoff *\/$/;"	v
gl_display	glvars.c	/^char *gl_display;$/;"	v
gl_fit	glvars.c	/^int gl_fit; \/* do not fit a variogram *\/$/;"	v
gl_fit_limit	glvars.c	/^double gl_fit_limit; \/* convergence criterion on fit *\/$/;"	v
gl_format	glvars.c	/^char *gl_format;$/;"	v
gl_fraction	glvars.c	/^double gl_fraction; \/* fraction of max dist for cutoff *\/$/;"	v
gl_gauss	glvars.c	/^int gl_gauss; \/* gaussian quadr. block covariances ? *\/$/;"	v
gl_gcv	glvars.c	/^double gl_gcv; \/* generalized covariance constant *\/$/;"	v
gl_gls_residuals	glvars.c	/^int gl_gls_residuals; \/* calc. gls residuals? *\/$/;"	v
gl_idp	glvars.c	/^double gl_idp; \/* default inverse distance power *\/$/;"	v
gl_iter	glvars.c	/^int gl_iter; \/* max. n. iter for mivque estimates *\/$/;"	v
gl_iwidth	glvars.c	/^double gl_iwidth; \/* variogram class width *\/$/;"	v
gl_jgraph	glvars.c	/^int gl_jgraph; \/* do jgraph plot in batch mode ? *\/$/;"	v
gl_lhs	glvars.c	/^int gl_lhs; \/* apply Latin hypercube sampling to Gaussian simulations *\/$/;"	v
gl_longlat	glvars.c	/^int gl_longlat; \/* indicates whether coordinates are longitude\/latitude, or Euclidian *\/$/;"	v
gl_marginal_names	glvars.c	/^char **gl_marginal_names;$/;"	v
gl_marginal_values	glvars.c	/^double *gl_marginal_values;$/;"	v
gl_mv_string	glvars.c	/^char *gl_mv_string;$/;"	v
gl_n_intervals	glvars.c	/^int gl_n_intervals; \/* n variogram intervals *\/$/;"	v
gl_n_marginals	glvars.c	/^int gl_n_marginals; \/* the n marginal distributions *\/$/;"	v
gl_n_uk	glvars.c	/^int gl_n_uk; \/* min. # of cs points to use ok *\/$/;"	v
gl_nblockdiscr	glvars.c	/^int gl_nblockdiscr; \/* block discrimination in each dimension *\/$/;"	v
gl_nocheck	glvars.c	/^int gl_nocheck; \/* do not check LMC\/IC ? *\/$/;"	v
gl_nsim	glvars.c	/^int gl_nsim; \/* number of simultanious simulations *\/$/;"	v
gl_numbers	glvars.c	/^int gl_numbers; \/* plot numbers on variogram plot? *\/$/;"	v
gl_order	glvars.c	/^int gl_order; \/* do order relation correction *\/$/;"	v
gl_pager	glvars.c	/^char *gl_pager;$/;"	v
gl_plotweights	glvars.c	/^int gl_plotweights; \/* plot kriging weights? *\/$/;"	v
gl_quantile	glvars.c	/^double gl_quantile; \/* sample quantile *\/$/;"	v
gl_register_pairs	glvars.c	/^int gl_register_pairs; \/* register sample variogram pairs? *\/$/;"	v
gl_rowwise	glvars.c	/^int gl_rowwise; \/* deal with raster maps row-wise, or as complete blocks? *\/$/;"	v
gl_rp	glvars.c	/^int gl_rp; \/* follow random path for gs\/is? *\/$/;"	v
gl_secure	glvars.c	/^int gl_secure; \/* disallow system() and popen()? *\/$/;"	v
gl_seed	glvars.c	/^int gl_seed; \/* seed is set? *\/$/;"	v
gl_sim_beta	glvars.c	/^int gl_sim_beta; \/* simulation mode for beta: 0 multiv GLS, 1 univ GLS, 2 OLS *\/$/;"	v
gl_sparse	glvars.c	/^int gl_sparse; \/* use sparse covariance matrices? *\/$/;"	v
gl_spiral	glvars.c	/^int gl_spiral; \/* do spiral search if possible? *\/$/;"	v
gl_split	glvars.c	/^int gl_split; \/* see nsearch.c: was Q_SPLIT_AT *\/$/;"	v
gl_sym_ev	glvars.c	/^int gl_sym_ev; \/* default symmetric ps.cr.v.\/cr.cv. ? *\/$/;"	v
gl_tol_hor	glvars.c	/^double gl_tol_hor;$/;"	v
gl_tol_ver	glvars.c	/^double gl_tol_ver;$/;"	v
gl_xvalid	glvars.c	/^int gl_xvalid; \/* do cross validation on first variable *\/$/;"	v
gl_zero	glvars.c	/^double gl_zero; \/* zero tolerance; 2-squared *\/$/;"	v
gl_zero_est	glvars.c	/^int gl_zero_est; \/* est. variogram at h 0 seperately? *\/$/;"	v
gl_zmap	glvars.c	/^double gl_zmap; \/* height of the map *\/$/;"	v
gls	gls.c	/^void gls(DATA **d \/* pointer to DATA array *\/,$/;"	f
grid_push_point	data.c	/^static void grid_push_point(DATA *d, DPOINT *p, int adjust_to_gridcentres) {$/;"	f	file:
gsetup_gridmap	data.c	/^DATA_GRIDMAP *gsetup_gridmap(double x_ul, double y_ul, double cellsizex, $/;"	f
gstat_S_fillgrid	s.c	/^static DATA_GRIDMAP *gstat_S_fillgrid(SEXP gridparams) {$/;"	f	file:
gstat_debug_level	s.c	/^SEXP gstat_debug_level(SEXP level) {$/;"	f
gstat_error	userio.c	/^void gstat_error(char *fname, int line, enum Gstat_errno err_nr, const char *msg) {$/;"	f
gstat_exit	s.c	/^SEXP gstat_exit(SEXP x) {$/;"	f
gstat_fit_variogram	s.c	/^SEXP gstat_fit_variogram(SEXP fit, SEXP fit_sill, SEXP fit_range) {$/;"	f
gstat_gcdist	gcdist.c	/^double gstat_gcdist(double lon1, double lon2, double lat1, double lat2) {$/;"	f
gstat_get_variogram_models	s.c	/^SEXP gstat_get_variogram_models(SEXP dolong) {$/;"	f
gstat_init	s.c	/^SEXP gstat_init(SEXP s_debug_level) {$/;"	f
gstat_load_command	s.c	/^SEXP gstat_load_command(SEXP commands) {$/;"	f
gstat_load_ev	s.c	/^SEXP gstat_load_ev(SEXP np, SEXP dist, SEXP gamma) {$/;"	f
gstat_load_variogram	s.c	/^SEXP gstat_load_variogram(SEXP s_ids, SEXP s_model, SEXP s_sills, SEXP s_ranges, $/;"	f
gstat_new_data	s.c	/^SEXP gstat_new_data(SEXP sy, SEXP slocs, SEXP sX, SEXP has_intercept, $/;"	f
gstat_new_dummy_data	s.c	/^SEXP gstat_new_dummy_data(SEXP loc_dim, SEXP has_intercept, SEXP beta, $/;"	f
gstat_predict	s.c	/^SEXP gstat_predict(SEXP sn, SEXP slocs, SEXP sX, SEXP block_cols, SEXP block, $/;"	f
gstat_set_block	s.c	/^static void gstat_set_block(long i, SEXP block, SEXP block_cols, DPOINT *current) {$/;"	f	file:
gstat_variogram	s.c	/^SEXP gstat_variogram(SEXP s_ids, SEXP cutoff, SEXP width, SEXP direction, $/;"	f
gstat_variogram_values	s.c	/^SEXP gstat_variogram_values(SEXP ids, SEXP pars, SEXP covariance, SEXP dist_values) {$/;"	f
gstat_yy_create_buffer	lex.c	/^    YY_BUFFER_STATE gstat_yy_create_buffer  (FILE * file, int  size )$/;"	f
gstat_yy_delete_buffer	lex.c	/^    void gstat_yy_delete_buffer (YY_BUFFER_STATE  b )$/;"	f
gstat_yy_flex_debug	lex.c	/^int gstat_yy_flex_debug = 0;$/;"	v
gstat_yy_flush_buffer	lex.c	/^    void gstat_yy_flush_buffer (YY_BUFFER_STATE  b )$/;"	f
gstat_yy_init_buffer	lex.c	/^    static void gstat_yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )$/;"	f	file:
gstat_yy_load_buffer_state	lex.c	/^static void gstat_yy_load_buffer_state  (void)$/;"	f	file:
gstat_yy_scan_buffer	lex.c	/^YY_BUFFER_STATE gstat_yy_scan_buffer  (char * base, yy_size_t  size )$/;"	f
gstat_yy_scan_bytes	lex.c	/^YY_BUFFER_STATE gstat_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )$/;"	f
gstat_yy_scan_string	lex.c	/^YY_BUFFER_STATE gstat_yy_scan_string (yyconst char * yystr )$/;"	f
gstat_yy_switch_to_buffer	lex.c	/^    void gstat_yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )$/;"	f
gstat_yyalloc	lex.c	/^void *gstat_yyalloc (yy_size_t  size )$/;"	f
gstat_yyensure_buffer_stack	lex.c	/^static void gstat_yyensure_buffer_stack (void)$/;"	f	file:
gstat_yyerror	parse.c	187;"	d	file:
gstat_yyfree	lex.c	/^void gstat_yyfree (void * ptr )$/;"	f
gstat_yyget_debug	lex.c	/^int gstat_yyget_debug  (void)$/;"	f
gstat_yyget_in	lex.c	/^FILE *gstat_yyget_in  (void)$/;"	f
gstat_yyget_leng	lex.c	/^int gstat_yyget_leng  (void)$/;"	f
gstat_yyget_lineno	lex.c	/^int gstat_yyget_lineno  (void)$/;"	f
gstat_yyget_out	lex.c	/^FILE *gstat_yyget_out  (void)$/;"	f
gstat_yyget_text	lex.c	/^char *gstat_yyget_text  (void)$/;"	f
gstat_yyin	lex.c	/^FILE *gstat_yyin = (FILE *) 0, *gstat_yyout = (FILE *) 0;$/;"	v
gstat_yyleng	lex.c	/^int gstat_yyleng;$/;"	v
gstat_yylex_destroy	lex.c	/^int gstat_yylex_destroy  (void)$/;"	f
gstat_yylineno	lex.c	/^int gstat_yylineno = 1;$/;"	v
gstat_yyout	lex.c	/^FILE *gstat_yyin = (FILE *) 0, *gstat_yyout = (FILE *) 0;$/;"	v
gstat_yypop_buffer_state	lex.c	/^void gstat_yypop_buffer_state (void)$/;"	f
gstat_yypush_buffer_state	lex.c	/^void gstat_yypush_buffer_state (YY_BUFFER_STATE new_buffer )$/;"	f
gstat_yyrealloc	lex.c	/^void *gstat_yyrealloc  (void * ptr, yy_size_t  size )$/;"	f
gstat_yyrestart	lex.c	/^    void gstat_yyrestart  (FILE * input_file )$/;"	f
gstat_yyset_debug	lex.c	/^void gstat_yyset_debug (int  bdebug )$/;"	f
gstat_yyset_in	lex.c	/^void gstat_yyset_in (FILE *  in_str )$/;"	f
gstat_yyset_lineno	lex.c	/^void gstat_yyset_lineno (int  line_number )$/;"	f
gstat_yyset_out	lex.c	/^void gstat_yyset_out (FILE *  out_str )$/;"	f
gstat_yytext	lex.c	/^char *gstat_yytext;$/;"	v
gstat_yywrap	lex.c	/^int gstat_yywrap(void) {$/;"	f
gstat_yywrap	lex.c	569;"	d	file:
id	parse.c	/^static int id = -1, id1 = -1, id2 = -1, col1 = -1, col2 = -1,$/;"	v	file:
id1	parse.c	/^static int id = -1, id1 = -1, id2 = -1, col1 = -1, col2 = -1,$/;"	v	file:
id2	parse.c	/^static int id = -1, id1 = -1, id2 = -1, col1 = -1, col2 = -1,$/;"	v	file:
ids	glvars.c	/^static char **outfile_names = NULL, **ids = NULL;$/;"	v	file:
in_bbox	nsearch.c	/^static int in_bbox(const DPOINT *where, BBOX bbox) {$/;"	f	file:
in_prod	mtrx.c	/^double in_prod(VEC *a, VEC *b) { \/* a'b *\/$/;"	f
init	sim.c	/^static int init = 0;$/;"	v	file:
init_data_minmax	data.c	/^void init_data_minmax(void) {$/;"	f
init_ev	vario.c	/^SAMPLE_VGM *init_ev(void) {$/;"	f
init_global_variables	glvars.c	/^int init_global_variables(void) {$/;"	f
init_gstat_data	glvars.c	/^static void init_gstat_data(int n) {$/;"	f	file:
init_lm	lm.c	/^LM *init_lm(LM *lm) {$/;"	f
init_one_data	data.c	/^DATA *init_one_data(DATA *data) {$/;"	f
init_qnode	nsearch.c	/^static void init_qnode(QTREE_NODE **p_node, int isleaf, BBOX bb) {$/;"	f	file:
init_qtree	nsearch.c	/^static void init_qtree(DATA *d) {$/;"	f	file:
init_queue	pqueue.c	/^QUEUE *init_queue(QUEUE *q, int (CDECL *cmp)(const Q_ELEMENT_WHAT *a, $/;"	f
init_simulations	msim.c	/^void init_simulations(DATA **d) {$/;"	f
init_variogram	vario.c	/^VARIOGRAM *init_variogram(VARIOGRAM *v) {$/;"	f
init_variogram_part	vario.c	/^static void init_variogram_part(VGM_MODEL *p) {$/;"	f	file:
input	lex.c	589;"	d	file:
input	lex.c	597;"	d	file:
intercept_only	data.c	/^int intercept_only(const DATA *d) {$/;"	f
inverse_dist	getest.c	/^static double inverse_dist(DATA *data, DPOINT *where, double idPow) {$/;"	f	file:
is_block_expr	parse.c	/^static int is_block_expr(GSTAT_EXPR *expr, const char *s) {$/;"	f	file:
is_data_expr	parse.c	/^static int is_data_expr(DATA *d, GSTAT_EXPR *expr, const char *fld) {$/;"	f	file:
is_directional	sem.c	/^int is_directional(VARIOGRAM *v) {$/;"	f
is_leaf	nsearch.c	88;"	d	file:
is_mv_double	utils.c	/^int is_mv_double(const double *d) {$/;"	f
is_mv_float	utils.c	/^int is_mv_float(const float *f) {$/;"	f
is_posdef	vario.c	/^static int is_posdef(MAT *A) {$/;"	f	file:
is_qtree_search	nsearch.c	89;"	d	file:
is_set_expr	parse.c	/^static int is_set_expr(GSTAT_EXPR *expr, const char *name) {$/;"	f	file:
is_simulation	glvars.c	/^int is_simulation(METHOD m) {$/;"	f
is_valid_cs	vario.c	/^static int is_valid_cs(const VARIOGRAM *aa, const VARIOGRAM *bb,$/;"	f	file:
iv_free	mtrx.c	/^void iv_free(IVEC *iv) {$/;"	f
iv_init	mtrx.c	/^IVEC *iv_init(void) {$/;"	f
iv_resize	mtrx.c	/^IVEC *iv_resize(IVEC *iv, size_t new_n) {$/;"	f
ival	parse.c	/^	int ival;$/;"	m	union:YYSTYPE	file:
lastnl	lex.c	/^static const char *yy_Source = NULL, *lastnl = NULL;$/;"	v	file:
lex_error	lex.c	/^void lex_error(void) {$/;"	f
limit	parse.c	/^	} limit;$/;"	m	struct:__anon2	typeref:enum:__anon2::__anon4	file:
logfile_name	glvars.c	/^char *logfile_name;$/;"	v
logprint_data_header	data.c	/^static void logprint_data_header(const DATA *d) {$/;"	f	file:
logprint_lm	lm.c	/^void logprint_lm(DATA *d, LM *lm) {$/;"	f
logprint_point	data.c	/^void logprint_point(const DPOINT *p, const DATA *d) {$/;"	f
logprint_qtree	nsearch.c	/^static void logprint_qtree(QTREE_NODE *node, int depth) {$/;"	f	file:
logprint_queue	nsearch.c	/^void logprint_queue(QUEUE *queue) {$/;"	f
logprint_variogram	vario.c	/^void logprint_variogram(const VARIOGRAM *v, int verbose) {$/;"	f
m_add	mtrx.c	/^MAT *m_add(MAT *m1, MAT *m2, MAT *out) { \/* out <- m1 + m2 *\/$/;"	f
m_copy	mtrx.c	/^MAT *m_copy(MAT *in, MAT *out){$/;"	f
m_free	mtrx.c	/^void m_free(MAT *m) {$/;"	f
m_init	mtrx.c	/^MAT *m_init(void) {$/;"	f
m_inverse	mtrx.c	/^MAT *m_inverse(MAT *in, MAT *out, int *info) { \/* out <- in^{-1} *\/$/;"	f
m_logoutput	lm.c	/^void m_logoutput(MAT * a) {$/;"	f
m_mlt	mtrx.c	/^MAT *m_mlt(MAT *m1, MAT *m2, MAT *out) { \/* out <- m1 m2 *\/$/;"	f
m_resize	mtrx.c	/^MAT *m_resize(MAT *m, size_t new_r, size_t new_c) {$/;"	f
m_sub	mtrx.c	/^MAT *m_sub(MAT *m1, MAT *m2, MAT *out) { \/* out <- m1 - m2 *\/$/;"	f
m_transp	mtrx.c	/^MAT *m_transp(MAT *in, MAT *out) { \/* out <- in' ; may be in situ *\/$/;"	f
m_zero	mtrx.c	/^MAT *m_zero(MAT *m) {$/;"	f
make_gls	gls.c	/^double *make_gls(DATA *d, int calc_residuals) {$/;"	f
make_gls_mv	gls.c	/^double *make_gls_mv(DATA **d, int n_vars) {$/;"	f
make_ols	lm.c	/^double *make_ols(DATA *d) {$/;"	f
make_residuals_lm	lm.c	/^void make_residuals_lm(DATA *d) {$/;"	f
map_rowcol2xy	mapio.c	/^int map_rowcol2xy(GRIDMAP * m,	\/* pointer to gridmap *\/$/;"	f
map_xy2rowcol	mapio.c	/^int map_xy2rowcol(GRIDMAP * m \/* pointer to map *\/ ,$/;"	f
max	data.c	/^static DPOINT min, max;$/;"	v	file:
max_block_dimension	glvars.c	/^double max_block_dimension(int reset) {$/;"	f
message	userio.c	/^void message(char *fmt, ...) {$/;"	f
method	glvars.c	/^static METHOD method = NSP;$/;"	v	file:
method_string	glvars.c	/^const char *method_string(METHOD i) {$/;"	f
methods	glvars.c	/^const METHODS methods[] = { \/* methods and codes *\/$/;"	v
min	data.c	/^static DPOINT min, max;$/;"	v	file:
mmtr_mlt	mtrx.c	/^MAT *mmtr_mlt(MAT *m1, MAT *m2, MAT *out) { \/* out <- m1 m2' *\/$/;"	f
mode	glvars.c	/^static MODE mode = MODE_NSP; \/* MODE_NSP, SIMPLE, STRATIFY or MULTIVARIABLE *\/$/;"	v	file:
model_shift	vario.c	/^VGM_MODEL_TYPE model_shift(VGM_MODEL_TYPE now, int next) {$/;"	f
ms_mltadd	mtrx.c	/^MAT *ms_mltadd(MAT *m1, MAT *m2, double s, MAT *out) { \/* out <- m1 + s * m2 *\/$/;"	f
msim	msim.c	/^	***msim = NULL, $/;"	v	file:
msim_base	msim.c	/^	**msim_base = NULL; \/* base structure for blocked allocation *\/$/;"	v	file:
mtrm_mlt	mtrx.c	/^MAT *mtrm_mlt(MAT *m1, MAT *m2, MAT *out) { \/* out <- m1'm2 *\/$/;"	f
mtrx_backsolve0	chol.c	/^static void mtrx_backsolve0(int trans, \/* transpose? *\/$/;"	f	file:
mtrx_chol0	chol.c	/^static void mtrx_chol0(int *N, double *A, int *info) {$/;"	f	file:
mu	gls.c	/^		*mu,       \/* mu vector, E(y) *\/$/;"	m	struct:__anon1	file:
mu0	gls.c	/^		*mu0,      \/* mu at loc x0 *\/$/;"	m	struct:__anon1	file:
mv_mlt	mtrx.c	/^VEC *mv_mlt(MAT *m, VEC *v, VEC *out) { \/* out <- m v *\/$/;"	f
my_rng	sim.c	/^} my_rng = { NULL, NULL };$/;"	v	typeref:struct:__anon5	file:
n_last	glvars.c	/^static int n_last = 0, n_v_last = 0, n_o_last = 0;$/;"	v	file:
n_o_last	glvars.c	/^static int n_last = 0, n_v_last = 0, n_o_last = 0;$/;"	v	file:
n_orvc	sim.c	/^static unsigned int n_orvc = 0, n_total = 0;$/;"	v	file:
n_pred_locs	msim.c	/^unsigned int n_pred_locs = 0;$/;"	v
n_sim_locs	msim.c	/^	*n_sim_locs = NULL, \/* n simulation locations per data variable *\/$/;"	v	file:
n_total	sim.c	/^static unsigned int n_orvc = 0, n_total = 0;$/;"	v	file:
n_v_last	glvars.c	/^static int n_last = 0, n_v_last = 0, n_o_last = 0;$/;"	v	file:
n_variograms_set	glvars.c	/^int n_variograms_set(void) {$/;"	f
n_vars	glvars.c	/^static int n_vars = 0;$/;"	v	file:
name	parse.c	/^	const char *name;$/;"	m	struct:__anon2	file:
name_identifier	glvars.c	/^const char *name_identifier(int i) {$/;"	f
new_glm	gls.c	/^static GLM *new_glm(void) {$/;"	f	file:
new_map	mapio.c	/^GRIDMAP *new_map(MAP_READ_STATUS status)$/;"	f
new_source	lex.c	/^	new_source = 0;$/;"	v	file:
node_cmp	nsearch.c	/^static int CDECL node_cmp(const QUEUE_NODE *a, const QUEUE_NODE *b) {$/;"	f	file:
nrangepars	parse.c	/^	fit_sill = 0, fit_range = 0, nrangepars = 1,$/;"	v	file:
o_filename	glvars.c	/^char *o_filename;$/;"	v
octant_select	select.c	/^static int octant_select(DATA *d, DPOINT *where) {$/;"	f	file:
ofn	parse.c	/^static char **ofn = NULL, *boundary_file = NULL;$/;"	v	file:
outfile_names	glvars.c	/^static char **outfile_names = NULL, **ids = NULL;$/;"	v	file:
output	lex.c	595;"	d	file:
output	lex.c	599;"	d	file:
p_init	mtrx.c	/^PERM *p_init(void) {$/;"	f
parse_cmd	parse.c	/^int parse_cmd(const char *cmd, const char *fname) {$/;"	f
parse_variogram	parse.c	/^static VARIOGRAM *parse_variogram = NULL;$/;"	v	file:
pb_norm_1D	nsearch.c	/^double pb_norm_1D(const DPOINT *where, BBOX bbox) {$/;"	f
pb_norm_2D	nsearch.c	/^double pb_norm_2D(const DPOINT *where, BBOX bbox) {$/;"	f
pb_norm_3D	nsearch.c	/^double pb_norm_3D(const DPOINT *where, BBOX bbox) {$/;"	f
pb_norm_gc2	data.c	/^static double pb_norm_gc2(const DPOINT *where, BBOX bbox) {$/;"	f	file:
point_norm_1D	data.c	/^static double point_norm_1D(const DPOINT *p) {$/;"	f	file:
point_norm_2D	data.c	/^static double point_norm_2D(const DPOINT *p) {$/;"	f	file:
point_norm_3D	data.c	/^static double point_norm_3D(const DPOINT *p) {$/;"	f	file:
point_norm_gc	data.c	/^static double point_norm_gc(const DPOINT *p) {$/;"	f	file:
polynomial	data.c	/^const POLY_NM polynomial[N_POLY] =$/;"	v
pop_point	data.c	/^void pop_point(DATA *d, int list_nr)$/;"	f
pp_norm_1D	data.c	/^static double pp_norm_1D(const DPOINT *a, const DPOINT *b) {$/;"	f	file:
pp_norm_2D	data.c	/^static double pp_norm_2D(const DPOINT *a, const DPOINT *b) {$/;"	f	file:
pp_norm_3D	data.c	/^static double pp_norm_3D(const DPOINT *a, const DPOINT *b) {$/;"	f	file:
pp_norm_gc	data.c	/^double pp_norm_gc(const DPOINT *a, const DPOINT *b) {$/;"	f
pp_norm_gc2	data.c	/^static double pp_norm_gc2(const DPOINT *a, const DPOINT *b) {$/;"	f	file:
pr_warning	userio.c	/^void pr_warning(char *fmt, ...) {$/;"	f
pred_lm	lm.c	/^void pred_lm(DATA **data, int n_vars, DPOINT *where, double *est) {$/;"	f
predict_lm	lm.c	/^static void predict_lm(LM *lm, MAT *X0, double *est) {$/;"	f	file:
print_data	data.c	/^void print_data(const DATA *d, int list) {$/;"	f
print_orvc	sim.c	/^void print_orvc(void) {$/;"	f
print_progress	userio.c	/^void print_progress(unsigned int current, unsigned int total) {$/;"	f
print_selection	select.c	/^static void print_selection(DATA *d, DPOINT *where) {$/;"	f	file:
print_sim	msim.c	/^void print_sim(void) {$/;"	f
printlog	userio.c	/^void printlog(const char *fmt, ...) {$/;"	f
ptr	parse.c	/^	void *ptr;$/;"	m	struct:__anon2	file:
push_bound	glvars.c	/^void push_bound(double value) {$/;"	f
push_d_vector	data.c	/^D_VECTOR *push_d_vector(double d, D_VECTOR *v) {$/;"	f
push_data_X	parse.c	/^static void push_data_X(DATA *d, int id) {$/;"	f	file:
push_marginal	parse.c	/^static void push_marginal(char *name, double value) {$/;"	f	file:
push_point	data.c	/^void push_point(DATA *d, const DPOINT *p) {$/;"	f
push_to_cloud	sem.c	/^static void push_to_cloud(SAMPLE_VGM *ev, double gamma, double dist,$/;"	f	file:
push_to_merge_table	data.c	/^int push_to_merge_table(DATA *d, int to_var, int col_this_X, int col_other_X) {$/;"	f
push_to_v	vario.c	/^void push_to_v(VARIOGRAM *v, const char *mod, double sill, double *range, $/;"	f
push_to_v_table	vario.c	/^void push_to_v_table(VARIOGRAM *v, double maxdist, int length, double *values,$/;"	f
push_variogram_model	vario.c	/^int push_variogram_model(VARIOGRAM *v, VGM_MODEL part) {$/;"	f
px_resize	mtrx.c	/^PERM *px_resize(PERM *p, size_t new_n) {$/;"	f
qtree_expand	nsearch.c	/^static QTREE_NODE *qtree_expand(const DPOINT *where, QTREE_NODE *root) {$/;"	f	file:
qtree_find_node	nsearch.c	/^static QTREE_NODE **qtree_find_node(const DPOINT *where, QTREE_NODE **p_node,$/;"	f	file:
qtree_free	nsearch.c	/^void qtree_free(QTREE_NODE *node) {$/;"	f
qtree_pop_point	nsearch.c	/^void qtree_pop_point(DPOINT *where, DATA *d) {$/;"	f
qtree_print	nsearch.c	/^void qtree_print(DATA *d) {$/;"	f
qtree_push	nsearch.c	/^static void qtree_push(DPOINT *where, QTREE_NODE **p_node, $/;"	f	file:
qtree_push_point	nsearch.c	/^void qtree_push_point(DATA *d, DPOINT *where) {$/;"	f
qtree_rebuild	nsearch.c	/^void qtree_rebuild(DATA *d) {$/;"	f
qtree_select	nsearch.c	/^int qtree_select(DPOINT *where, DATA *d) {$/;"	f
qtree_split_node	nsearch.c	/^static void qtree_split_node(QTREE_NODE *node, BBOX bbox, int rec_level) {$/;"	f	file:
qtree_zero_all_leaves	nsearch.c	/^static void qtree_zero_all_leaves(QTREE_NODE *node) {$/;"	f	file:
r_normal	s.c	/^double r_normal(void) {$/;"	f
r_normal	sim.c	/^	double (*r_normal)(void);$/;"	m	struct:__anon5	file:
r_unif	sim.c	/^	double (*r_unif)(void);$/;"	m	struct:__anon5	file:
r_uniform	s.c	/^double r_uniform(void) {$/;"	f
range	parse.c	/^static double range[NRANGEPARS], anis[5];$/;"	v	file:
read_double	read.c	/^int read_double(const char *s, double *d) {$/;"	f
read_float	read.c	/^int read_float(const char *s, float *f) {$/;"	f
read_int	read.c	/^int read_int(const char *s, int *i) {$/;"	f
read_long	read.c	/^int read_long(const char *s, long int *l) {$/;"	f
read_uint	read.c	/^int read_uint(const char *s, unsigned int *u) {$/;"	f
read_ulong	read.c	/^int read_ulong(const char *s, unsigned long *u) {$/;"	f
register_pairs	sem.c	/^static void *register_pairs(void *pairs, unsigned long nh,$/;"	f	file:
relative_nugget	vario.c	/^double relative_nugget(VARIOGRAM *v) {$/;"	f
reml	reml.c	/^static int reml(VEC *Y, MAT *X, MAT **Vk, int n_k, int max_iter,$/;"	f	file:
reml_sills	reml.c	/^VARIOGRAM *reml_sills(DATA *data, VARIOGRAM *vp) {$/;"	f
remove_all	glvars.c	/^void remove_all(void) {$/;"	f
remove_id	glvars.c	/^int remove_id(const int id) {$/;"	f
reset_anyway	block.c	/^int reset_anyway = 0;$/;"	v
reset_block_discr	block.c	/^void reset_block_discr(void) {$/;"	f
reset_lex	lex.c	/^static void reset_lex(void) {$/;"	f	file:
reset_parser	parse.c	/^static void reset_parser(void) {$/;"	f	file:
reset_variogram_parameters	getest.c	/^void reset_variogram_parameters(VARIOGRAM *v) {$/;"	f
resize_ev	sem.c	/^static void resize_ev(SAMPLE_VGM *ev, unsigned int size) {$/;"	f	file:
restore_data_sel	msim.c	/^void restore_data_sel(DATA **data, int sim, int n_vars) {$/;"	f
s2d	msim.c	/^	**s2d = NULL, $/;"	v	file:
sample_mean	stat.c	/^double sample_mean(double *list, int n) {$/;"	f
sample_std	stat.c	/^double sample_std(double *list, double mean, int n) {$/;"	f
sample_var	stat.c	/^double sample_var(double *list, double mean, int n) {$/;"	f
save_sim	msim.c	/^void save_sim(DATA **data, DPOINT *where, int sim, int n_vars,$/;"	f
save_sim_strat	msim.c	/^void save_sim_strat(DATA *d, DPOINT *where, int sim, double value, int is_pt) {$/;"	f
save_variogram_parameters	getest.c	/^void save_variogram_parameters(VARIOGRAM *v) {$/;"	f
sd_vector	parse.c	/^static D_VECTOR *sd_vector = NULL;$/;"	v	file:
seed_is_in	s.c	/^static int seed_is_in = 0;$/;"	v	file:
select_at	select.c	/^int select_at(DATA *d, DPOINT *where) {$/;"	f
select_qtree	select.c	/^static int select_qtree(DATA *d, DPOINT *where)$/;"	f	file:
sem_cov_ab	vario_io.c	/^double sem_cov_ab(VARIOGRAM *v, DPOINT *a, DPOINT *b, int sem)$/;"	f
sem_cov_blocks	vario_io.c	/^static double sem_cov_blocks(VARIOGRAM *v, DATA *a, DATA *b, int sem) {$/;"	f	file:
semivariogram	sem.c	/^static SAMPLE_VGM *semivariogram(DATA *d, SAMPLE_VGM *ev) {$/;"	f	file:
semivariogram_grid	sem.c	/^static SAMPLE_VGM *semivariogram_grid(DATA *d, SAMPLE_VGM *ev) {$/;"	f	file:
semivariogram_list	sem.c	/^static SAMPLE_VGM *semivariogram_list(DATA *d, SAMPLE_VGM *ev) {$/;"	f	file:
set_back_radius	select.c	57;"	d	file:
set_beta	msim.c	/^void set_beta(DATA **d, int sim, int n_vars, METHOD method) {$/;"	f
set_col	mtrx.c	/^void set_col(MAT *M, size_t i, VEC *col) {$/;"	f
set_direction_values	direct.c	/^void set_direction_values(double a, double b, double t_h, double t_v) {$/;"	f
set_lex_source	lex.c	/^void set_lex_source(const char *source, const char *fname) {$/;"	f
set_method	glvars.c	/^void set_method(METHOD m) {$/;"	f
set_mode	glvars.c	/^void set_mode(void) {$/;"	f
set_mv_double	utils.c	/^void set_mv_double(double *d) {$/;"	f
set_mv_float	utils.c	/^void set_mv_float(float *f) {$/;"	f
set_norm_fns	data.c	/^void set_norm_fns(DATA *d) {$/;"	f
setup_beta	msim.c	/^void setup_beta(DATA **d, int n_vars, int n_sim) {$/;"	f
setup_data_minmax	data.c	/^void setup_data_minmax(DATA *d) {$/;"	f
setup_polynomial_X	data.c	/^void setup_polynomial_X(DATA *d) {$/;"	f
setup_valdata_X	glvars.c	/^void setup_valdata_X(DATA *d) {$/;"	f
short	parse.c	301;"	d	file:
simulate_mvn	sim.c	/^static void simulate_mvn(const double *est, VEC *result, const int *is_datum) {$/;"	f	file:
simulate_uniform	sim.c	/^static void simulate_uniform(double *est, VEC *result, int orc) {$/;"	f	file:
sm_mlt	mtrx.c	/^MAT *sm_mlt(double s, MAT *m1, MAT *out) { \/* out <- s * m1 *\/$/;"	f
sprint_variogram	vario.c	/^const char *sprint_variogram(const VARIOGRAM *v, int verbose) {$/;"	f
start	utils.c	/^static time_t start;$/;"	v	file:
store_radius	select.c	56;"	d	file:
strcat_tm	vario.c	/^static void strcat_tm(char *cp, ANIS_TM *tm) {$/;"	f	file:
string_casecmp	utils.c	/^int string_casecmp(const char *a, const char *b) {$/;"	f
string_cat	utils.c	/^const char *string_cat(const char *s, const char *t) {$/;"	f
sub_bbox	nsearch.c	/^static BBOX sub_bbox(const BBOX bbox, int index) {$/;"	f	file:
sv_mlt	mtrx.c	/^VEC *sv_mlt(double s, VEC *v, VEC *out) { \/* out <- s * v *\/$/;"	f
sval	parse.c	/^	char *sval;$/;"	m	union:YYSTYPE	file:
table_size	msim.c	/^	table_size = 0, \/* offset strata table size *\/$/;"	v	file:
tol_hor	direct.c	/^	tol_hor = PI, tol_ver = PI,$/;"	v	file:
tol_ver	direct.c	/^	tol_hor = PI, tol_ver = PI,$/;"	v	file:
trace_matrix	reml.c	/^static double trace_matrix(MAT *m) {$/;"	f	file:
transform_norm	vario.c	/^double transform_norm(const ANIS_TM *tm, double dx, double dy, double dz) {$/;"	f
unput	lex.c	592;"	d	file:
unput	lex.c	598;"	d	file:
unquote	lex.c	/^static char *unquote(const char *txt) {$/;"	f	file:
update_variogram	vario.c	/^void update_variogram(VARIOGRAM *vp) {$/;"	f
uval	parse.c	/^	unsigned int uval;$/;"	m	union:YYSTYPE	file:
v	parse.c	/^static VARIOGRAM *v = NULL;$/;"	v	file:
v_add	mtrx.c	/^VEC *v_add(VEC *v1, VEC *v2, VEC *out) { \/* out = v1 + v2 *\/$/;"	f
v_bin	data.c	/^double v_bin(double mu) {$/;"	f
v_copy	mtrx.c	/^VEC *v_copy(VEC *in, VEC *out){$/;"	f
v_free	mtrx.c	/^void v_free(VEC *v) {$/;"	f
v_identity	data.c	/^double v_identity(double mu) {$/;"	f
v_init	mtrx.c	/^VEC *v_init(void) {$/;"	f
v_logoutput	lm.c	/^void v_logoutput(VEC * x) {$/;"	f
v_models	vario.c	/^const V_MODEL v_models[] = { \/* the variogram model ``data base'': *\/$/;"	v
v_mu	data.c	/^double v_mu(double mu) {$/;"	f
v_mu2	data.c	/^double v_mu2(double mu) {$/;"	f
v_mu3	data.c	/^double v_mu3(double mu) {$/;"	f
v_norm2	mtrx.c	/^double v_norm2(VEC *v) { \/* 2-norm  *\/$/;"	f
v_resize	mtrx.c	/^VEC *v_resize(VEC *v, size_t new_n) {$/;"	f
v_sub	mtrx.c	/^VEC *v_sub(VEC *v1, VEC *v2, VEC *out) { \/* out = v1 - v2 *\/$/;"	f
v_zero	mtrx.c	/^VEC *v_zero(VEC *v) {$/;"	f
valdata	glvars.c	/^static DATA *valdata = NULL;$/;"	v	file:
valid_direction	direct.c	/^double valid_direction(DPOINT *a, DPOINT *b, int symmetric, const DATA *d) {$/;"	f
valid_distance	sem.c	/^static double valid_distance(DPOINT *a, DPOINT *b, double max, $/;"	f	file:
vector_only	parse.c	/^	vector_only = 0, allow_vector_only = 0;$/;"	v	file:
verify_data	parse.c	/^static void verify_data(DATA *d) { \/* declaration : contents *\/$/;"	f	file:
vgm	glvars.c	/^static VARIOGRAM **vgm = NULL;$/;"	v	file:
vgm_init_block_values	vario.c	/^void vgm_init_block_values(VARIOGRAM *v) {$/;"	f
vgm_pars	getest.c	/^static double *vgm_pars = NULL;$/;"	v	file:
vgm_type_str	vario.c	/^const char *vgm_type_str[] = { $/;"	v
vm_mlt	mtrx.c	/^VEC *vm_mlt(MAT *m, VEC *v, VEC *out) { \/* out <- v m *\/$/;"	f
what	parse.c	/^	} what;$/;"	m	struct:__anon2	typeref:enum:__anon2::__anon3	file:
what_is_outfile	glvars.c	/^const char *what_is_outfile(int i) {$/;"	f
which_identifier	glvars.c	/^int which_identifier(const char *id) {$/;"	f
which_octant	select.c	/^static int which_octant(DPOINT *where, DPOINT *p, int mode) {$/;"	f	file:
which_point	msim.c	/^static DPOINT *which_point(DATA *d, DPOINT *where) {$/;"	f	file:
which_variogram_model	vario.c	/^VGM_MODEL_TYPE which_variogram_model(const char *m) {$/;"	f
wls_fit	fit.c	/^static void wls_fit(VARIOGRAM *vp) {$/;"	f	file:
write_error	mapio.c	/^static GRIDMAP *write_error(GRIDMAP * m)$/;"	f	file:
y	gls.c	/^	VEC *y,        \/* measurement vector *\/$/;"	m	struct:__anon1	file:
yy_File_name	lex.c	/^static const char *yy_File_name = NULL;$/;"	v	file:
yy_Lexpos	lex.c	/^static int yy_Lexpos = 0, yy_Posafternl = 1, My_yy_lineno = 1,$/;"	v	file:
yy_Posafternl	lex.c	/^static int yy_Lexpos = 0, yy_Posafternl = 1, My_yy_lineno = 1,$/;"	v	file:
yy_Source	lex.c	/^static const char *yy_Source = NULL, *lastnl = NULL;$/;"	v	file:
yy_accept	lex.c	/^static yyconst flex_int16_t yy_accept[41] =$/;"	v	file:
yy_at_bol	lex.c	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	file:
yy_base	lex.c	/^static yyconst flex_int16_t yy_base[49] =$/;"	v	file:
yy_bs_column	lex.c	/^    int yy_bs_column; \/**< The column count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_bs_lineno	lex.c	/^    int yy_bs_lineno; \/**< The line count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_pos	lex.c	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_size	lex.c	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	file:
yy_buffer_stack	lex.c	/^static YY_BUFFER_STATE * yy_buffer_stack = 0; \/**< Stack as an array. *\/$/;"	v	file:
yy_buffer_stack_max	lex.c	/^static size_t yy_buffer_stack_max = 0; \/**< capacity of stack. *\/$/;"	v	file:
yy_buffer_stack_top	lex.c	/^static size_t yy_buffer_stack_top = 0; \/**< index of top of stack. *\/$/;"	v	file:
yy_buffer_state	lex.c	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_status	lex.c	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	file:
yy_c_buf_p	lex.c	/^static char *yy_c_buf_p = (char *) 0;$/;"	v	file:
yy_ch_buf	lex.c	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_chk	lex.c	/^static yyconst flex_int16_t yy_chk[91] =$/;"	v	file:
yy_create_buffer	lex.c	8;"	d	file:
yy_def	lex.c	/^static yyconst flex_int16_t yy_def[49] =$/;"	v	file:
yy_delete_buffer	lex.c	9;"	d	file:
yy_did_buffer_switch_on_eof	lex.c	/^static int yy_did_buffer_switch_on_eof;$/;"	v	file:
yy_ec	lex.c	/^static yyconst flex_int32_t yy_ec[256] =$/;"	v	file:
yy_fatal_error	lex.c	/^static void yy_fatal_error (yyconst char* msg )$/;"	f	file:
yy_fill_buffer	lex.c	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_flex_debug	lex.c	10;"	d	file:
yy_flex_strlen	lex.c	/^static int yy_flex_strlen (yyconst char * s )$/;"	f	file:
yy_flex_strncpy	lex.c	/^static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )$/;"	f	file:
yy_flush_buffer	lex.c	12;"	d	file:
yy_get_next_buffer	lex.c	/^static int yy_get_next_buffer (void)$/;"	f	file:
yy_get_previous_state	lex.c	/^    static yy_state_type yy_get_previous_state (void)$/;"	f	file:
yy_hold_char	lex.c	/^static char yy_hold_char;$/;"	v	file:
yy_init	lex.c	/^static int yy_init = 0;		\/* whether we need to initialize *\/$/;"	v	file:
yy_init_buffer	lex.c	11;"	d	file:
yy_init_globals	lex.c	/^static int yy_init_globals (void)$/;"	f	file:
yy_input_file	lex.c	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	file:
yy_is_interactive	lex.c	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	file:
yy_is_our_buffer	lex.c	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_last_accepting_cpos	lex.c	/^static char *yy_last_accepting_cpos;$/;"	v	file:
yy_last_accepting_state	lex.c	/^static yy_state_type yy_last_accepting_state;$/;"	v	file:
yy_load_buffer_state	lex.c	13;"	d	file:
yy_meta	lex.c	/^static yyconst flex_int32_t yy_meta[15] =$/;"	v	file:
yy_n_chars	lex.c	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	file:
yy_n_chars	lex.c	/^static int yy_n_chars;		\/* number of characters read into yy_ch_buf *\/$/;"	v	file:
yy_new_buffer	lex.c	338;"	d	file:
yy_nxt	lex.c	/^	flex_int32_t yy_nxt;$/;"	m	struct:yy_trans_info	file:
yy_nxt	lex.c	/^static yyconst flex_int16_t yy_nxt[91] =$/;"	v	file:
yy_reduce_print	parse.c	/^yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)$/;"	f	file:
yy_set_bol	lex.c	350;"	d	file:
yy_set_interactive	lex.c	340;"	d	file:
yy_size_t	lex.c	/^typedef size_t yy_size_t;$/;"	t	file:
yy_stack_print	parse.c	/^yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)$/;"	f	file:
yy_start	lex.c	/^static int yy_start = 0;	\/* start state number *\/$/;"	v	file:
yy_state_type	lex.c	/^typedef int yy_state_type;$/;"	t	file:
yy_switch_to_buffer	lex.c	14;"	d	file:
yy_symbol_print	parse.c	/^yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_symbol_value_print	parse.c	/^yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_trans_info	lex.c	/^struct yy_trans_info$/;"	s	file:
yy_try_NUL_trans	lex.c	/^    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )$/;"	f	file:
yy_verify	lex.c	/^	flex_int32_t yy_verify;$/;"	m	struct:yy_trans_info	file:
yyalloc	lex.c	23;"	d	file:
yyalloc	parse.c	/^union yyalloc$/;"	u	file:
yychar	parse.c	/^int yychar;$/;"	v
yychar	parse.c	70;"	d	file:
yycheck	parse.c	/^static const yytype_uint8 yycheck[] =$/;"	v	file:
yyclearin	parse.c	874;"	d	file:
yyconst	lex.c	125;"	d	file:
yyconst	lex.c	127;"	d	file:
yydebug	parse.c	/^int yydebug;$/;"	v
yydebug	parse.c	66;"	d	file:
yydefact	parse.c	/^static const yytype_uint8 yydefact[] =$/;"	v	file:
yydefgoto	parse.c	/^static const yytype_int16 yydefgoto[] =$/;"	v	file:
yydestruct	parse.c	/^yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)$/;"	f	file:
yyerrok	parse.c	873;"	d	file:
yyerror	parse.c	65;"	d	file:
yyfree	lex.c	25;"	d	file:
yyin	lex.c	15;"	d	file:
yyinput	lex.c	/^    static int yyinput (void)$/;"	f	file:
yyleng	lex.c	16;"	d	file:
yyless	lex.c	1814;"	d	file:
yyless	lex.c	1815;"	d	file:
yyless	lex.c	194;"	d	file:
yylex	lex.c	17;"	d	file:
yylex	parse.c	64;"	d	file:
yylineno	lex.c	18;"	d	file:
yylval	lex.c	557;"	d	file:
yylval	parse.c	/^YYSTYPE yylval;$/;"	v
yylval	parse.c	69;"	d	file:
yymore	lex.c	501;"	d	file:
yynerrs	parse.c	/^int yynerrs;$/;"	v
yynerrs	parse.c	67;"	d	file:
yyout	lex.c	19;"	d	file:
yypact	parse.c	/^static const yytype_int16 yypact[] =$/;"	v	file:
yypact_value_is_default	parse.c	648;"	d	file:
yyparse	parse.c	/^yyparse (void)$/;"	f
yyparse	parse.c	63;"	d	file:
yypgoto	parse.c	/^static const yytype_int16 yypgoto[] =$/;"	v	file:
yyr1	parse.c	/^static const yytype_uint8 yyr1[] =$/;"	v	file:
yyr2	parse.c	/^static const yytype_uint8 yyr2[] =$/;"	v	file:
yyrealloc	lex.c	24;"	d	file:
yyrestart	lex.c	20;"	d	file:
yyrline	parse.c	/^static const yytype_uint16 yyrline[] =$/;"	v	file:
yyss_alloc	parse.c	/^  yytype_int16 yyss_alloc;$/;"	m	union:yyalloc	file:
yystos	parse.c	/^static const yytype_uint8 yystos[] =$/;"	v	file:
yystpcpy	parse.c	/^yystpcpy (char *yydest, const char *yysrc)$/;"	f	file:
yystpcpy	parse.c	1075;"	d	file:
yystrlen	parse.c	/^yystrlen (const char *yystr)$/;"	f	file:
yystrlen	parse.c	1059;"	d	file:
yysyntax_error	parse.c	/^yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,$/;"	f	file:
yytable	parse.c	/^static const yytype_uint8 yytable[] =$/;"	v	file:
yytable_value_is_error	parse.c	653;"	d	file:
yyterminate	lex.c	755;"	d	file:
yytext	lex.c	21;"	d	file:
yytext_ptr	lex.c	375;"	d	file:
yytname	parse.c	/^static const char *const yytname[] =$/;"	v	file:
yytnamerr	parse.c	/^yytnamerr (char *yyres, const char *yystr)$/;"	f	file:
yytokentype	parse.c	/^  enum yytokentype$/;"	g	file:
yytoknum	parse.c	/^static const yytype_uint16 yytoknum[] =$/;"	v	file:
yytranslate	parse.c	/^static const yytype_uint8 yytranslate[] =$/;"	v	file:
yytype_int16	parse.c	/^typedef YYTYPE_INT16 yytype_int16;$/;"	t	file:
yytype_int16	parse.c	/^typedef short int yytype_int16;$/;"	t	file:
yytype_int8	parse.c	/^typedef YYTYPE_INT8 yytype_int8;$/;"	t	file:
yytype_int8	parse.c	/^typedef signed char yytype_int8;$/;"	t	file:
yytype_uint16	parse.c	/^typedef YYTYPE_UINT16 yytype_uint16;$/;"	t	file:
yytype_uint16	parse.c	/^typedef unsigned short int yytype_uint16;$/;"	t	file:
yytype_uint8	parse.c	/^typedef YYTYPE_UINT8 yytype_uint8;$/;"	t	file:
yytype_uint8	parse.c	/^typedef unsigned char yytype_uint8;$/;"	t	file:
yyunput	lex.c	/^    static void yyunput (int c, register char * yy_bp )$/;"	f	file:
yyvs_alloc	parse.c	/^  YYSTYPE yyvs_alloc;$/;"	m	union:yyalloc	file:
yywrap	lex.c	22;"	d	file:
zero_int2enum	vario.c	/^DO_AT_ZERO zero_int2enum(int zero) {$/;"	f
zero_shift	vario.c	/^DO_AT_ZERO zero_shift(DO_AT_ZERO now, int next) {$/;"	f
zero_weights_count	lm.c	/^static int zero_weights_count(LM *lm) {$/;"	f	file:
